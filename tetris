#!/usr/bin/python
"""
A python implementation of tetris.

Kevin Cuzner

This is more of an experiment on different things, like emulating C#
events (which I think are awesome), reading XML, and using curses
(although that may change eventually).

This uses the data.xml file to locate block shapes to use in the game.
The colors for the blocks are also set there as well.
"""

import curses
import random, time, datetime, math, os, threading
import xml.etree.ElementTree as ET
from abc import ABCMeta, abstractmethod

class EventDispatcher(object):
    """
    Event object which operates like C# events
    
    "event += handler" adds a handler to this event
    "event -= handler" removes a handler from this event
    "event(*arguments)" calls all of the handlers with the passed
    arguments
    
    Events may be temporarily suppressed by using them in a with
    statement. The context returnd will be this event object.
    """
    def __init__(self):
        """
        Initializes a new event
        """
        self.__handlers = []
        self.__supress_count = 0
    def __call__(self, e):
        if self.__supress_count > 0:
            return
        for h in self.__handlers:
            h(e)
    def __iadd__(self, other):
        if other not in self.__handlers:
            self.__handlers.append(other)
        return self
    def __isub__(self, other):
        self.__handlers.remove(other)
        return self
    def __enter__(self):
        self.__supress_count += 1
        return self
    def __exit__(self, exc_type, exc_value, traceback):
        self.__supress_count -= 1

class Event(object):
    """
    Instance of an event to be dispatched
    """
    def __init__(self, target, *args, **kwargs):
        self.target = target
        self.args = args
        self.kwargs = kwargs

class Movable(object):
    """
    Object with a moveable event and parentage
    
    The moved event has the following siguature:
    (self, current_position, last_position)
        self: The block object that initiated the event
        current_position: self explanatory
        last_position: position as recorded directly before movement
    """
    def __init__(self, local_position, parent=None):
        self.__parent = parent
        self.__local_position = local_position
        self.changed_event = EventDispatcher()
        self.changed_event += self.__on_changed
    def __on_changed(self, e):
        if hasattr(self.__parent, 'changed_event'):
            self.__parent.changed_event(e)
    @property
    def parent(self):
        return self.__parent
    @parent.setter
    def parent(self, value):
        l = self.position
        self.__parent = value
        self.changed_event(Event(self, event="parent-changed", current=self.position, last=l))
    @property
    def local_position(self):
        return self.__local_position
    @local_position.setter
    def local_position(self, value):
        l = self.position
        self.__local_position = value
        self.changed_event(Event(self, event="position-changed", current=self.position, last=l))
    @property
    def position(self):
        origin = (0,0)
        if self.__parent is not None:
            origin = self.__parent.position
        return self.__translate_position(origin)
        
    def __translate_position(self, origin):
        """
        Returns this block's position translated to an origin
        """
        return (origin[0] + self.__local_position[0], origin[1] + \
                self.__local_position[1])

class Block(Movable):
    """
    Block with a moved event
    """
    def __init__(self, local_position, color, parent=None):
        """
        Initializes the block
        
        parent: Object with a position property used as an origin.
          If none, (0,0) is used. If the parent has a moved event, it
          will be subscribed to
        lx: x position relative to parent
        ly: y position relative to parent
        color: color number to use
        """
        super().__init__(local_position, parent)
        self.__color = color
    @property
    def color(self):
        return self.__color

class Polyomino(Movable):
    def __init__(self, local_position, parent=None):
        super().__init__(local_position, parent)
        self.blocks = []
    def __check_locations(self, locations):
        pos = self.local_position
        if self.parent is None or not hasattr(self.parent, 'is_clear'):
            return True
        for l in locations:
            if not self.parent.is_clear((pos[0] + l[0], pos[1] + l[1])):
                #raise Exception(pos, l)
                return False
        return True
    def rotate_left(self):
        """
        Attempts to rotate this polyomino left
        """
        new_local_positions = []
        # rotation equation: sin(90)=1 cos(90)=0
        # x' = x*cos(theta) - y*sin(theta)
        # y' = x*sin(theta) + y*cos(theta)
        for b in self.blocks:
            x = b.local_position[0]
            y = b.local_position[1]
            new_local_positions.append((-y, x, b))
        if not self.__check_locations(new_local_positions):
            return False
        for p in new_local_positions:
            p[2].local_position = (p[0], p[1])
        self.changed_event(Event(self, event="rotated"))
        return True
    def rotate_right(self):
        """
        Attempts to rotate this polyomino right
        """
        new_local_positions = []
        # rotation equation: sin(-90)=-1 cos(-90)=0
        # x' = x*cos(theta) - y*sin(theta)
        # y' = x*sin(theta) + y*cos(theta)
        for b in self.blocks:
            x = b.local_position[0]
            y = b.local_position[1]
            new_local_positions.append((y, -x, b))
        if not self.__check_locations(new_local_positions):
            return False
        for p in new_local_positions:
            p[2].local_position = (p[0], p[1])
        self.changed_event(Event(self, event="rotated"))
        return True
    def move_down(self):
        """
        Attempts to move this polyomino down
        """
        return move_delta((0, 1))
    def move_delta(self, delta):
        """
        Attempts to move this polyomino to the passed position
        """
        new_local_positions = []
        dx = delta[0]
        dy = delta[1]
        for b in self.blocks:
            x = b.local_position[0]
            y = b.local_position[1]
            new_local_positions.append((x + dx, y + dy, b))
        if not self.__check_locations(new_local_positions):
            return False
        # update our position, no need to opdate our children's position
        self.local_position = (self.local_position[0] + dx,\
                               self.local_position[1] + dy)
        self.changed_event(Event(self, event="moved", delta=delta))
        return True
        
class PolyominoFactory(object):
    """
    Factory callable class for polyominos
    """
    def __init__(self, blocktuples, color):
        """
        Creates a new factory
        
        blocktupes: Set of tuples of (x,y) for each block location
        color: Color number to use for this polyomino
        """
        self.tuples = blocktuples
        self.color = color
    def __call__(self, grid, position):
        """
        Creates a polyomino at the passed location
        """
        polyomino = Polyomino(position, parent=grid)
        for pos in self.tuples:
            polyomino.blocks.append(Block(pos, self.color, \
                                          parent=polyomino))
        return polyomino

class Grid(Movable):
    """
    Represents a game grid
    """
    def __init__(self, position=(0,0), width=10, height=20):
        super().__init__(position)
        self.width = width
        self.height = height
        self.grid = []
        for x in range(width):
            self.grid.append([])
            for y in range(height):
                self.grid[x].append(None)
    def is_clear(self, position):
        """
        Returns true if the passed relative position is clear on the
        board
        """
        x = position[0]
        y = position[1]
        if y < 0:
            return True # we have no bound on the upper side
        if x < 0 or x >= self.width or y >= self.height:
            return False
        return True if self.grid[x][y] is None else False
    def add_polyomino(self, polyomino):
        """
        Adds the passed block to this grid. This modifies the blocks
        in the passed polyomino to be relative to the grid. If the
        polyomino's parent is this grid, it no longer has a parent
        """
        # we want the block positions relative to the polyomino, not
        # relative to the parent of the polyomino (us).
        if polyomino.parent is self:
            polyomino.parent = None # should make the origin (0,0)
        for b in polyomino.blocks:
            # we can suppress the move event here since we are simply
            # removing a level of parentage
            lp = b.local_position
            p = b.position
            with b.changed_event: # suppress events from the block
                b.local_position = b.position # as we change position
                b.parent = None
            self.grid[b.position[0]][b.position[1]] = b
            b.parent = self # the block is relative to us now
            self.changed_event(Event(self, event="block-added", block=b))
    def clear_rows(self):
        removed = []
        for y in range(self.height):
            row = True
            for x in range(self.width):
                if self.grid[x][y] is None:
                    row = False
                    break
            if row:
                # move the blocks above this one down one row
                # we can do this since we proceed from row 0 upwards
                for x in range(self.width):
                    removed.append(self.grid[x][y])
                for y_p in range(y, 0, -1):
                    for x in range(self.width):
                        self.grid[x][y_p] = self.grid[x][y_p-1]
                        if self.grid[x][y_p] is not None:
                            lpos = self.grid[x][y_p].local_position
                            self.grid[x][y_p].local_position =\
                                (lpos[0], lpos[1]+1)
                for x in range(self.width):
                    self.grid[x][0] = None
        return removed

class Tetris(object):
    """
    Tetris game
    """
    def __init__(self, position, block_factories):
        """
        Initializes this tetris game with the passed block_types.
        """
        self.grid = Grid(position)
        self.__current_piece = None
        self.delta = datetime.timedelta()
        self.__score = 0
        self.__level = 1
        self.__lines = 0
        self.changed_event = EventDispatcher()
        self.possible_blocks = block_factories
    def __get_new_block(self, position):
        n = random.randrange(0, len(self.possible_blocks))
        return self.possible_blocks[n](self.grid, position)
    @property
    def current_piece(self):
        return self.__current_piece
    @current_piece.setter
    def current_piece(self, value):
        l = self.current_piece
        self.__current_piece = value
        self.changed_event(Event(self, event="current-piece-changed",\
                current_pice=self.current_piece, last=l))
    @property
    def score(self):
        return self.__score
    @score.setter
    def score(self, value):
        self.__score = value
        self.changed_event(Event(self, event="score-changed",\
                score=self.score))
    @property
    def level(self):
        return self.__level
    @level.setter
    def level(self, value):
        self.__level = value
        self.changed_event(Event(self, event="level-changed",\
                level=self.level))
    @property
    def lines(self):
        return self.__lines;
    @lines.setter
    def lines(self, value):
        self.__lines = value
        self.changed_event(Event(self, event="lines-changed",\
                lines=self.lines))
    def step(self, delta):
        self.delta += delta
        min_delta = datetime.timedelta(seconds=0.5 / self.level)
        if self.delta >= min_delta:
            self.delta = datetime.timedelta()
            new_piece = False
            if self.current_piece == None:
                new_piece = True
                self.current_piece = \
                    self.__get_new_block((int(self.grid.width / 2), 0))
            # attempt to move the piece down
            if not self.down():
                if new_piece:
                    return False # the game is done
                # check for rows
                self.grid.add_polyomino(self.current_piece)
                self.current_piece = None
                cleared = self.grid.clear_rows()
                self.lines += int(len(cleared) / self.grid.width)
                self.score += int(len(cleared) * (len(cleared) /\
                                                      self.grid.width))
                self.level = int(math.floor(self.lines / 10)) + 1
        return True # continue the game
    def rotate_left(self):
        if self.current_piece is not None:
            if self.current_piece.rotate_left():
                self.changed_event(Event(self, event="piece-rotated-left"))
                return True
        return False
    def rotate_right(self):
        if self.current_piece is not None:
            if self.current_piece.rotate_right():
                self.changed_event(Event(self, event="piece-rotated-right"))
                return True
        return False
    def left(self):
        if self.current_piece is not None:
            if self.current_piece.move_delta((-1, 0)):
                self.changed_event(Event(self, event="piece-moved"))
                return True
        return False
    def right(self):
        if self.current_piece is not None:
            if self.current_piece.move_delta((1, 0)):
                self.changed_event(Event(self, event="piece-moved"))
                return True
        return False
    def down(self):
        if self.current_piece is not None:
            if self.current_piece.move_delta((0, 1)):
                self.changed_event(Event(self, event="piece-moved"))
                return True
        return False
    
class StateManager(object):
    """
    Manages game state and serves as a gateway to the active state
    """
    def __init__(self, initial_state):
        """
        Creates a new manager with an initial state
        
        initial_state: State that will be initialized and entered into
        """
        self.__states = []
        self.__data = {} # shared data for the states
        self.push_state(initial_state)
        self.empty = EventDispatcher() # happens when there are no states
    def push_state(self, state):
        """
        Pushes a new state onto the stack and makes it active
        """
        if self.active_state is not None:
            self.active_state.exit()
        state.init(self)
        state.enter()
        self.__states.append(state)
    def pop_state(self):
        """
        Pops the active state from the stack if it exists and enters
        the next state down
        """
        if self.active_state is not None:
            self.active_state.exit()
            self.__states.pop()
        if self.active_state is not None:
            self.active_state.enter()
        else:
            self.empty(self)
    def replace_state(self, state):
        """
        Replaces the current state with the passed state
        """
        if self.active_state is None:
            self.push_state(state)
        else:
            self.active_state.exit()
            self.__states.pop()
            self.push_state(state)
    @property
    def active_state(self):
        """
        Returns the active state
        """
        if len(self.__states) > 0:
            return self.__states[-1]
        return None
    @property
    def data(self):
        """
        Returns the shared data for this manager
        """
        return self.__data
    def input(self, char):
        """
        Sends the passed character into the active state as input
        """
        if self.active_state is not None:
            self.active_state.input(char)
    def render(self, window, delta, terminal_size=None):
        """
        Renders the current state onto the passed window
        
        window: Curses window to render to
        delta: Seconds that have passed since the last render
        """
        if self.active_state is not None:
            self.active_state.render(window, delta, terminal_size)

class State(metaclass=ABCMeta):
    """
    Base class for a state
    """
    @abstractmethod
    def init(self, manager):
        pass
    @abstractmethod
    def enter(self):
        pass
    @abstractmethod
    def exit(self):
        pass
    @abstractmethod
    def input(self, char):
        """
        Process the passed character as input
        """
        pass
    @abstractmethod
    def render(self, window, delta, terminal_size=None):
        """
        Render this state to the passed window
        """
        pass
        

class StateInitializationException(Exception):
    """
    Exception to be raised when a state cannot initialize itself due
    to one reason or another
    """
    def __init__(self, reason):
        self.reason = reason
    def __str__(self):
        return repr(self.reason)
        
class LoadState(State):
    """
    State which loads the initial resources for the game
    """
    def __load(self):
        # attempt to load the data
        colordefs = {}
        block_types = {}
        tree = ET.parse('data.xml')
        root = tree.getroot()
        if root is not None:
            for color in root.findall('color'):
                colordefs[color.get('id')] = \
                    (get_curses_color(color.get('fg')), \
                     get_curses_color(color.get('bg')))
            for t in root.findall('type'):
                polyominoes = []
                for p in t.findall('polyomino'):
                    blocktuples = []
                    for b in p.findall('block'):
                        blocktuples.append((int(b.get('x')), \
                                            int(b.get('y'))))
                    polyominoes.append(PolyominoFactory(blocktuples,\
                                       int(p.get('color'))))
                block_types[t.get('name')] = polyominoes
        self.manager.data["block_types"] = block_types
        # set up the color definitions
        for i in colordefs:
            color = colordefs[i]
            curses.init_pair(int(i), color[0], color[1])
    def init(self, manager):
        self.manager = manager
        self.loading_thread = threading.Thread(target=self.__load)
        self.loading_thread.start()
    def enter(self):
        pass
    def exit(self):
        pass
    def input(self, char):
        if char == 27: # end this state
            self.loading_thread.join()
            self.manager.pop_state()
    def render(self, window, delta, terminal_size=None):
        if not self.loading_thread.is_alive(): # become the main menu
            self.manager.replace_state(MainMenuState())
            return
        window.clear()
        window.border()
        if terminal_size is None:
            window.addstr(1, 1, "Loading...%s" % str(delta))
        else:
            window.addstr(int(terminal_size.lines / 2),\
                          int(terminal_size.columns / 2) - 5,\
                          "Loading...")

class MainMenuState(State):
    """
    State for when the game is at the main menu
    """
    MENU = [ "New Game", "High Scores", "Quit" ]
    NEW_GAME_INDEX = 0
    HIGH_SCORES_INDEX = 1
    QUIT_INDEX = 2
    def init(self, manager):
        self.manager = manager
        self.changed = False
        self.selected = 0 # selected menu index
    def enter(self): 
        self.changed = True # when we enter, we change
    def exit(self):
        pass
    def input(self, char):
        if char == 27:
            self.manager.pop_state()
        elif char == curses.KEY_UP and self.selected > 0:
            self.selected -= 1
            self.changed = True
        elif char == curses.KEY_DOWN and \
                self.selected < len(MainMenuState.MENU) - 1:
            self.selected += 1
            self.changed = True
        elif char == 10:
            if self.selected == MainMenuState.NEW_GAME_INDEX:
                self.manager.push_state(NewGameMenuState())
            elif self.selected == MainMenuState.HIGH_SCORES_INDEX:
                self.manager.push_state(HighScoresState())
            elif self.selected == MainMenuState.QUIT_INDEX:
                self.manager.pop_state()
            self.changed = True
    def render(self, window, delta, terminal_size=None):
        if not self.changed:
            return
        window.clear()
        window.border()
        title = "Tetris"
        dash = "---"
        menu = "Main Menu"
        window.addstr(1, self.__get_column(terminal_size, title), title)
        window.addstr(3, self.__get_column(terminal_size, dash), dash)
        window.addstr(4, self.__get_column(terminal_size, menu), menu)
        for i in range(len(MainMenuState.MENU)):
            phrase = MainMenuState.MENU[i]
            attr = curses.A_STANDOUT if i == self.selected else 0
            window.addstr(6 + i, \
                          self.__get_column(terminal_size, phrase),\
                          phrase, attr)
        self.changed = False
    def __get_column(self, terminal_size, phrase):
        if terminal_size == None:
            return 0
        else:
            return int(terminal_size.columns / 2) - int(len(phrase) / 2)

class NewGameMenuState(State):
    """
    State for when creating a new game
    """
    def init(self, manager):
        self.manager = manager
        if "block_types" not in self.manager.data:
            raise Exception(self.manager.data)
            #raise StateInitializationException(\
            #        "Block types uninitialized")
        if len(self.manager.data["block_types"]) == 0:
            raise StateInitializationException("No block types loaded")
        self.block_types = list(self.manager.data["block_types"].keys())
        self.block_types.sort()
        self.selected = 0
        self.changed = False
    def enter(self):
        self.changed = True
    def exit(self):
        pass
    def input(self, char):
        if char == curses.KEY_UP and self.selected > 0:
            self.selected -= 1
            self.changed = True
        elif char == curses.KEY_DOWN and\
                self.selected < len(self.block_types)-1:
            self.selected += 1
            self.changed = True
        elif char == 10:
            # create a new game
            blocks = self.manager.data["block_types"][self.block_types[self.selected]]
            self.manager.replace_state(GameState(blocks))
    def render(self, window, delta, terminal_size=None):
        if not self.changed:
            return
        window.clear()
        window.border()
        title = "Select a game type:"
        window.addstr(2, self.__get_column(terminal_size, title), title)
        for i in range(len(self.block_types)):
            phrase = self.block_types[i]
            attr = curses.A_STANDOUT if i == self.selected else 0
            window.addstr(4 + i, \
                          self.__get_column(terminal_size, phrase),\
                          phrase, attr)
        self.changed = False
    def __get_column(self, terminal_size, phrase):
        if terminal_size == None:
            return 0
        else:
            return int(terminal_size.columns / 2) - int(len(phrase) / 2)
    
class HighScoresState(State):
    """
    State for viewing the high scores
    """
    def init(self, manager):
        self.manager = manager
    def enter(self):
        pass
    def exit(self):
        pass
    def input(self, char):
        pass
    def render(self, window, delta, terminal_size=None):
        self.manager.pop_state()
    
class GameState(State):
    """
    State for playing a game
    """
    def __init__(self, blocks):
        self.changed = False
        self.game = Tetris((35, 1), blocks)
        self.game.changed_event += self.__on_game_changed
    def __on_game_changed(self, e):
        self.changed = True
    def init(self, manager):
        self.manager = manager
    def enter(self):
        self.changed = True
    def exit(self):
        pass
    def input(self, char):
        if char == 27:
            self.manager.pop_state()
        elif char == curses.KEY_UP:
            self.game.rotate_left()
        elif char == curses.KEY_LEFT:
            self.game.left()
        elif char == curses.KEY_RIGHT:
            self.game.right()
        elif char == curses.KEY_DOWN:
            self.game.down()
    def render(self, window, delta, terminal_size=None):
        if not self.game.step(delta):
            self.manager.pop_state()
            return
        if not self.changed:
            return # nothing to do here
        window.clear()
        window.border()
        window.hline(21, 34, ord('-'), 12)
        window.vline(1, 34, ord('|'), 20)
        window.vline(1, 45, ord('|'), 20)
        if self.game.current_piece is not None:
            for b in self.game.current_piece.blocks:
                window.addch(b.position[1], b.position[0],\
                             ord('#'),\
                             curses.color_pair(b.color))
        for x in range(self.game.grid.width):
            for y in range(self.game.grid.height):
                b = self.game.grid.grid[x][y]
                if b is not None:
                    window.addch(b.position[1], b.position[0],\
                                 ord('#'),\
                                 curses.color_pair(b.color))
        window.addstr(10, 50, "Score: %i" % self.game.score)
        window.addstr(11, 50, "Lines: %i" % self.game.lines)
        window.addstr(12, 50, "Level: %i" % self.game.level)
        self.changed = False

class Application(object):
    def __init__(self, window):
        self.window = window
        window.nodelay(1)
        self.manager = StateManager(LoadState())
        self.running = True
        self.manager.empty += self.stop # stop when manager stack empty
    def stop(self, manager):
        self.running = False
    def run(self):
        curses.curs_set(0)
        last_render = datetime.datetime.now()
        size = os.get_terminal_size()
        while(self.running):
            active = None
            while active is not self.manager.active_state:
                # we don't stop this until the state settles down
                recvd = self.window.getch()
                if recvd != -1:
                    self.manager.input(recvd)
                now = datetime.datetime.now()
                self.manager.render(self.window, now - last_render, size)
                active = self.manager.active_state
            last_render = now
            self.window.refresh()
            time.sleep(1/30)
        return
        
def get_curses_color(name):
    if name == "black":
        return curses.COLOR_BLACK
    elif name == "blue":
        return curses.COLOR_BLUE
    elif name == "cyan":
        return curses.COLOR_CYAN
    elif name == "green":
        return curses.COLOR_GREEN
    elif name == "magenta":
        return curses.COLOR_MAGENTA
    elif name == "red":
        return curses.COLOR_RED
    elif name == "white":
        return curses.COLOR_WHITE
    elif name == "yellow":
        return curses.COLOR_YELLOW
    else:
        return None
    
def main(window):
    app = Application(window)
    app.run()

if __name__ == "__main__":
    curses.wrapper(main)
